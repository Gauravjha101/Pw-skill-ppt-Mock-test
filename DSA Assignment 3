"ASSIGNMENT
    "QUESTION 3
    
    "ðŸ’¡ A1 class Solution:\n",
    "def threeSumClosest(self, nums: List[int], target: int) -> int:\n",
    "nums.sort()\n",
    "result = float('inf')\n",
    "stored_sum = 0\n",
    "for i in range(len(nums) - 2):\n",
    "left = i + 1\n",
    "right = len(nums) - 1\n",
    "while left < right:\n",
    "k = nums[i] + nums[left] + nums[right]\n",
    "if k > target:\n",
    "right -= 1\n",
    "elif k < target:\n",
    "left += 1\n",
    "else:\n",
    "return k\n",
    "if abs(target - k) < result:\n",
    "result = abs(target - k)\n",
    "stored_sum = k\n",
    "return stored_sum\n",
    "\n",
    
    "ðŸ’¡ A2 class Solution:\n",
    "def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n",
    "def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n",
    "res = []\n",
    "# If we have run out of numbers to add, return res.\n",
    "if not nums:\n",
    "return res\n",
    "# There are k remaining values to add to the sum. The\n",
    "# average of these values is at least target // k.\n",
    "average_value = target // k\n",
    "# We cannot obtain a sum of target if the smallest value\n",
    "# in nums is greater than target // k or if the largest\n",
    "# value in nums is smaller than target // k.\n",
    "if average_value < nums[0] or nums[-1] < average_value:\n",
    "return res\n",
    "if k == 2:\n",
    "return twoSum(nums, target)\n",
    "for i in range(len(nums)):\n",
    "if i == 0 or nums[i - 1] != nums[i]:\n",
    "for subset in kSum(nums[i + 1:], target - nums[i], k - 1):\n",
    "res.append([nums[i]] + subset)\n",
    "return res\n",
    "def twoSum(nums: List[int], target: int) -> List[List[int]]:\n",
    "res = []\n",
    "lo, hi = 0, len(nums) - 1\n",
    "while (lo < hi):\n",
    "curr_sum = nums[lo] + nums[hi]\n",
    "if curr_sum < target or (lo > 0 and nums[lo] == nums[lo - 1]):\n",
    "lo += 1\n",
    "elif curr_sum > target or (hi < len(nums) - 1 and nums[hi] == nums[hi + 1]):\n",
    "hi -= 1\n",
    "else:\n",
    "res.append([nums[lo], nums[hi]])\n",
    "lo += 1\n",
    "hi -= 1\n",
    "return res\n",
    "nums.sort()\n",
    "return kSum(nums, target, 4)\n",
    "\n",
    
    "ðŸ’¡ A3 class Solution {\n",
    "void nextPermutation(int[] nums) {\n",
    "int i = nums.length - 2;\n",
    "while (i >= 0 && nums[i + 1] <= nums[i]) {\n",
    "i--;\n",
    "}\n",
    "if (i >= 0) {\n",
    "int j = nums.length - 1;\n",
    "while (nums[j] <= nums[i]) {\n",
    "j--;\n",
    "}\n",
    "swap(nums, i, j);\n",
    "}\n",
    "reverse(nums, i + 1);\n",
    "}\n",
    "private void reverse(int[] nums, int start) {\n",
    "int i = start, j = nums.length - 1;\n",
    "while (i < j) {\n",
    "swap(nums, i, j);\n",
    "i++;\n",
    "j--;\n",
    "}\n",
    "}\n",
    "private void swap(int[] nums, int i, int j) {\n",
    "int temp = nums[i];\n",
    "nums[i] = nums[j];\n",
    "nums[j] = temp;\n",
    "}\n",
    "}\n",
    "\n",
    
    "ðŸ’¡ A4 class Solution:\n",
    "def searchInsert(self, nums: List[int], target: int) -> int:\n",
    "left,right=0,len(nums)-1\n",
    "while left<=right:\n",
    "mid=(left+right)//2\n",
    "if nums[mid]==target:\n",
    "return mid\n",
    "elif nums[mid]<target:\n",
    "left=mid+1\n",
    "else:\n",
    "right=mid-1\n",
    "return left\n",
    "\n",
    
    "ðŸ’¡ A5 class Solution:\n",
    "def plusOne(self, digits: List[int]) -> List[int]:\n",
    "integer = 0\n",
    "for i in digits:\n",
    "integer = integer*10 + i\n",
    "integer += 1\n",
    "res = []\n",
    "while integer != 0:\n",
    "res.insert(0, integer % 10)\n",
    "integer = integer//10\n",
    "return res\n",
    "\n",
    
    "ðŸ’¡ A6 class Solution(object):\n",
    "def singleNumber(self, nums):\n",
    "# Initialize the unique number...\n",
    "uniqNum = 0;\n",
    "# TRaverse all elements through the loop...\n",
    "for idx in nums:\n",
    "# Concept of XOR...\n",
    "uniqNum ^= idx;\n",
    "return uniqName; # Return the unique numberâ€¦\n",
    "\n",
    
    "ðŸ’¡ A7 class Solution:\n",
    "def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:\n",
    "def f(a, b):\n",
    "return str(a) if a == b else f'{a}->{b}'\n",
    "n = len(nums)\n",
    "if n == 0:\n",
    "return [f(lower, upper)]\n",
    "ans = []\n",
    "if nums[0] > lower:\n",
    "ans.append(f(lower, nums[0] - 1))\n",
    "for a, b in pairwise(nums):\n",
    "if b - a > 1:\n",
    "ans.append(f(a + 1, b - 1))\n",
    "if nums[-1] < upper:\n",
    "ans.append(f(nums[-1] + 1, upper))\n",
    "return ans\n",
    "\n",
    
    "ðŸ’¡ A8 class Solution {\n",
    "public boolean canAttendMeetings(int[][] intervals) {\n",
    "int len = intervals.length;\n",
    "int[] startTime = new int[len];\n",
    "int[] endTime = new int[len];\n",
    "int count = 0;\n",
    "for(int[] interval: intervals){\n",
    "startTime[count] = interval[0];\n",
    "endTime[count++] = interval[1];\n",
    "}\n",
    "Arrays.sort(startTime);\n",
    "Arrays.sort(endTime);\n",
    "for(int i = 1; i < len; i++){\n",
    "if(startTime[i] < endTime[i - 1]) return false;\n",
    "}\n",
    "return true;\n",
    "}\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}

