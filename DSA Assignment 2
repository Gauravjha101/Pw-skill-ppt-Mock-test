 "ASSIGNMENT
    "QUESTION 2
    
    
    "ðŸ’¡ A1 class Solution:\n",
    "def arrayPairSum(self, nums: List[int]) -> int:\n",
    "K = 10000\n",
    "# Store the frequency of each element\n",
    "element_to_count = [0] * (2 * K + 1)\n",
    "for element in nums:\n",
    "# Add K to element to offset negative values\n",
    "element_to_count[element + K] += 1\n",
    "# Initialize sum to zero\n",
    "max_sum = 0\n",
    "is_even_index = True\n",
    "for element in range(2 * K + 1):\n",
    "while element_to_count[element] > 0 :\n",
    "# Add element if it is at even index\n",
    "if is_even_index:\n",
    "max_sum += element - K\n",
    "# Flip the value (one to zero or zero to one)\n",
    "is_even_index = not is_even_index;\n",
    "# Decrement the frequency count\n",
    "element_to_count[element] -= 1\n",
    "return max_sum\n",
    "\n",
    
    "ðŸ’¡ A2 class Solution {\n",
    "int distributeCandies(int[] candyType) {\n",
    "// Initiate a variable to count how many unique candies are in the array.\n",
    "int uniqueCandies = 0;\n",
    "// For each candy, we're going to check whether or not we've already\n",
    "// seen a candy identical to it.\n",
    "for (int i = 0; i < candyType.length; i++) {\n",
    "// Start by assuming that the candy IS unique.\n",
    "boolean isUnique = true;\n",
    "// Check each candy BEFORE this candy.\n",
    "for (int j = 0; j < i; j++) {\n",
    "// If this candy is the same as a previous one, it isn't unique.\n",
    "if (candyType[i] == candyType[j]) {\n",
    "isUnique = false;\n",
    "break;\n",
    "}\n",
    "}\n",
    "if (isUnique) {\n",
    "uniqueCandies++;\n",
    "}\n",
    "}\n",
    "// The answer is the minimum out of the number of unique candies, and\n",
    "// half the length of the candyType array.\n",
    "return Math.min(uniqueCandies, candyType.length / 2);\n",
    "}\n",
    "}\n",
    "\n",
    
    "ðŸ’¡ A3 class Solution {\n",
    "int findLHS(int[] nums) {\n",
    "int res = 0;\n",
    "for (int i = 0; i < (1 << nums.length); i++) {\n",
    "int count = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n",
    "for (int j = 0; j < nums.length; j++) {\n",
    "if ((i & (1 << j)) != 0) {\n",
    "min = Math.min(min, nums[j]);\n",
    "max = Math.max(max, nums[j]);\n",
    "count++;\n",
    "}\n",
    "}\n",
    "if (max - min == 1)\n",
    "res = Math.max(res, count);\n",
    "}\n",
    "return res;\n",
    "}\n",
    "}\n",
    "\n",
    
    "ðŸ’¡ A4 class Solution:\n",
    "def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n",
    "count = 0\n",
    "for i in range(len(flowerbed)):\n",
    "# Check if the current plot is empty.\n",
    "if flowerbed[i] == 0:\n",
    "# Check if the left and right plots are empty.\n",
    "empty_left_plot = (i == 0) or (flowerbed[i - 1] == 0)\n",
    "empty_right_lot = (i == len(flowerbed) - 1) or (flowerbed[i + 1] == 0)\n",
    "# If both plots are empty, we can plant a flower here.\n",
    "if empty_left_plot and empty_right_lot:\n",
    "flower bed[i] = 1\n",
    "count += 1\n",
    "return count >= n\n",
    "\n",
    
    "ðŸ’¡ A5 class Solution {\n",
    "int maximumProduct(int[] nums) {\n",
    "int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n",
    "int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;\n",
    "for (int n: nums) {\n",
    "if (n <= min1) {\n",
    "min2 = min1;\n",
    "min1 = n;\n",
    "} else if (n <= min2) { // n lies between min1 and min2\n",
    "min2 = n;\n",
    "}\n",
    "if (n >= max1) { // n is greater than max1, max2 and max3\n",
    "max3 = max2;\n",
    "max2 = max1;\n",
    "max1 = n;\n",
    "} else if (n >= max2) { // n lies betweeen max1 and max2\n",
    "max3 = max2;\n",
    "max2 = n;\n",
    "} else if (n >= max3) { // n lies betwen max2 and max3\n",
    "max3 = n;\n",
    "}\n",
    "}\n",
    "return Math.max(min1 * min2 * max1, max1 * max2 * max3);\n",
    "}\n",
    "}\n",
    "\n",
    
    "ðŸ’¡ A6 class Solution:\n",
    "def search(self, nums: List[int], target: int) -> int:\n",
    "# Set the left and right boundaries\n",
    "left = 0\n",
    "right = len(nums) - 1\n",
    "# Under this condition\n",
    "while left <= right:\n",
    "# Get the middle index and the middle value.\n",
    "mid = (left + right) // 2\n",
    "# Case 1, return the middle index.\n",
    "if nums[mid] == target:\n",
    "return mid\n",
    "# Case 2, discard the smaller half.\n",
    "elif nums[mid] < target:\n",
    "left = mid + 1\n",
    "# Case 3, discard the larger half.\n",
    "else:\n",
    "right = mid - 1\n",
    "# If we finish the search without finding a target, return -1.\n",
    "return -1\n",
    "\n",
    
    "ðŸ’¡ A7 class Solution(object):\n",
    "def isMonotonic(self, A):\n",
    "store = 0\n",
    "for i in xrange(len(A) - 1):\n",
    "c = cmp(A[i], A[i+1])\n",
    "if c:\n",
    "if c != store != 0:\n",
    "return False\n",
    "store = c\n",
    "return True\n",
    "\n",
    
    "ðŸ’¡ A8 static boolean containsPairWithSum(int[] a, int x) {\n",
    "Arrays.sort(a);\n",
    "for (int i = 0, j = a.length - 1; i < j;) {\n",
    "int sum = a[i] + a[j];\n",
    "if (sum < x)\n",
    "i++;\n",
    "else if (sum > x)\n",
    "j--;\n",
    "else\n",
    "return true;\n",
    "}\n",
    "return false;\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}

